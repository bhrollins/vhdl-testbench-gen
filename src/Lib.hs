module Lib
    ( generateTestbench
    ) where

import Options
import Types
import Parser

import Data.Maybe (fromMaybe)
import Text.Parsec.Text
import System.IO (writeFile)
import System.Environment (getProgName)
import System.FilePath (dropExtension, FilePath)
import System.Directory (doesFileExist)

{- | 'generateTestbench' invokes 'vhdlToTestbench' with arguments from the
     command-line and writes its results to a file
    
    @todo clean this function up
 -}
generateTestbench :: Options -> IO ()
generateTestbench opts = do
    let force = forceWrite opts
        input = inputFile opts
        output = getOutputFile opts
    
    exists <- doesFileExist output
    if exists && not force then
        putStrLn $ output ++ " exists. Use `-f` or `--force` option to overwrite existing file or specify different output path."
    else
        do
            progName <- getProgName
            result <- parseFromFile vhdlParser input
            case result of
                Left err -> print err
                Right parsed -> writeFile output $ vhdlToTestbench progName output parsed

{- | 'vhdlToTestbench' converts a parsed VHDL source file as the pseudo-AST 'VhdlFile'
     to plain text which can be written to a file
 -}
vhdlToTestbench :: String -> FilePath -> VhdlFile -> String
vhdlToTestbench progName outputPath (VhdlFile name generics ports) =
    concatFile [ commentHeader
                , [ "library ieee;"
                ,   "use ieee.std_logic_1164.all;"
                ,   ""
                ,   "entity " ++ tbName ++ " is"
                ,   "end " ++ tbName ++ ";"
                ,   ""
                ,   "architecture behavior of " ++ tbName ++ " is"
                ,   tab ++ "component " ++ name ++ " is" ]
                , prependTabs 2 genericParams
                , prependTabs 2 portParams
                , [ tab ++ "end component;"
                  ]
                , [ "" ]
                , prependTabs 1 constants
                , [ "" ]
                , prependTabs 1 signals
                , [ "" ]
                , [ "begin"
                  , tab ++ "uut: " ++ name
                  ]
                , prependTabs 2 genericMap
                , prependTabs 2 portMap
                , [ "" ]
                -- @todo add default clock and reset processes by either detecting idiomatic 
                --       reset & clock names or specifying through command-line arguments
                , [ "end;"]
               ]
    where
        commentHeader :: [String]
        commentHeader = [ "-- scaffolding for `" ++ outputPath ++ "` generated by " ++ progName
                        , "-- see <url> for implementation details/bug reporting"
                        ]

        -- | 'tab' simply defines a tab "character" as 4 spaces
        --   
        --   @todo make this user-configurable (number of spaces or actual tab character)
        --         via command-line arguments
        tab :: String
        tab = replicate 4 ' '

        tabs :: Int -> String -> String
        tabs 0 x = x
        tabs n x = (tab ++) $ tabs (n-1) x

        prependTabs n = map (tabs n)

        tbName :: String
        tbName = dropExtension outputPath

        concatFile :: [[String]] -> String
        concatFile = unlines . concat

        {- | 'concatMapDropLast' applies a function over a collection,
             concatenating the result, then drops the last character 
             in the last element of the resulting list
             this is used to remove a trailing ',' or ';' in a port map or 
             parameter list
          
           @todo find a better way to do this, by "this" ideally we don't need
                 to drop these after creating the list
        -}
        concatMapDropLast :: (a -> [String]) -> [a] -> [String]
        concatMapDropLast f xs = let xs' = concatMap f xs in
                                     init xs' ++ [(init . last) xs']

        paramFiller :: (a -> [String]) -> String -> [a] -> [String]
        paramFiller g p = concat . paramFiller' g p
            where
                paramFiller' :: (a -> [String]) -> String -> [a] -> [[String]]
                paramFiller' g p xs = [ [ p ]
                                      , [ "(" ]
                                      , concatMapDropLast g xs
                                      , [ ");" ]
                                      ]

        genericParams :: [String]
        genericParams = maybe [] (paramFiller genParam "generic") generics
            where
                genParam :: Generic -> [String]
                genParam (Generic names t v) = map generic names
                    where
                        generic n = tab ++ n ++ " : " ++ t ++ ";"
        
        portParams :: [String]
        portParams = paramFiller portParam "port" ports
            where
                portParam :: Port -> [String]
                portParam (Port names d t v) = map port names
                    where
                        port n = tab ++ n ++ " : " ++ d ++ " " ++ t ++ ";"

        paramMap :: String -> (a -> [String]) -> [a] -> [String]
        paramMap param names = concat . mapFiller
            where
                mapFiller xs = [ [ param ++ " map" ]
                               , [ "(" ]
                               , concatMapDropLast mapNames xs
                               , [ ")" ]
                               ] 
                
                mapNames = map (\x -> tab ++ x ++ " => " ++ x ++ ",") . names

        genericMap :: [String]
        genericMap = maybe [] (paramMap "generic" gnames) generics
            where
                gnames :: Generic -> [String]
                gnames (Generic names _ _) = names

        portMap :: [String]
        portMap = portMap'
            where
                portMap' :: [String]
                portMap' = init (paramMap "port" pnames ports) ++ [ ");" ]
                
                pnames :: Port -> [String]
                pnames (Port names _ _ _) = names

        value :: Maybe String -> String
        value = maybe "" (" := " ++)

        constants :: [String]
        constants = maybe [] (concatMap constant) generics
            where
                constant (Generic names t v) = map constants' names
                    where
                        constants' n = "constant " ++ n ++ " : " ++ t ++ value v ++ ";"

        signals :: [String]
        signals = concatMap sig ports
            where
                sig (Port names _ t v) = map signals' names
                    where
                        signals' n = "signal " ++ n ++ " : " ++ t ++ value v ++ ";"

